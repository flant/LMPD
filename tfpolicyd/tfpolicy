#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#		Main process(connection manager) for policyd
#       server.py
#       
#       Copyright (C) 2009-2011 CJSC TrueOffice (www.trueoffice.ru)
#		Written by Nikolay aka GyRT Bogdanov <nikolay.bogdanov@trueoffice.ru>
#       
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 2 of the License, or
#       any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.

import os, sys, signal, site, argparse #, setproctitle

#Importing our modules
site.addsitedir("/usr/lib/python2.6/tfpolicyd/lib", known_paths=None)
site.addsitedir("/usr/lib/python2.6/tfpolicyd/plugins", known_paths=None)
site.addsitedir("/usr/lib/python2.6/tfpolicyd/lib/PySQLPool", known_paths=None)
import Config, Init, Connection, Policy, Worker, Logger, PySQLPool, Reloader


def main():
	parser = argparse.ArgumentParser(description='SMTP policy whitelisting daemon.')
	parser.add_argument('-c', '--config', help='Path to a config file', default='/etc/postfix/tfpolicyd.yaml')
	parser.add_argument('-p', '--pid', help='Path to a PID file', default='/tmp/tfpolicyd.pid')
	parser.add_argument('-d', dest='is_daemon', action='store_true', help='Become a daemon', default=False)
	args = parser.parse_args()	

	#setproctitle.setproctitle(' '.join(sys.argv)) 

	Init.check_clone(args.pid)

	#reading config
	config = Config.Config(args.config)

	# set uid and gid
	Init.baseinit(config)
	
	# creating socket
	socket = Init.createsock(config)
	
	# creating mysql pool
	mysql_config = config.get("mysql", False)
	if mysql_config:
		PySQLPool.getNewPool().maxActiveConnections = config.get("mysql_pool", 10)
		sql_pool = PySQLPool.getNewConnection(username=config.get("mysql_user", "root"), password=config.get("mysql_password", ""), host=config.get("mysql_host", "localhost"), db=config.get("mysql_dbname", "postfix"), port=config.get("mysql_port", 3306))
	else:
		print "Lost fields in mysql config. Exiting..."
		sys.exit(1)

	# loading filters names from config
	flt_names = config.get("filters_order", False)
	if not flt_names:
		flt_names = ["AddressPolicy","DomainPolicy","UserPolicy"]

	# loading filters
	flts = []
	for flt_name in flt_names:
		globals()[flt_name] = locals()[flt_name] = __import__(flt_name, globals(), locals(), [], -1)
		flt = getattr(locals()[flt_name], flt_name)(config, sql_pool)
		flts.append(flt)

	# Loading default answer for postfix
	default_answer = config.get("filters_default", False)
	if not default_answer:
		print "Lost fields in filter config. Exiting..."
		sys.exit(1)

	signal.signal(signal.SIGTERM, lambda x, y: Init.SIGINT_handler(args.pid, x, y))
	signal.signal(signal.SIGINT, lambda x, y: Init.SIGINT_handler(args.pid, x, y))
	signal.signal(signal.SIGHUP, signal.SIG_IGN)

	if args.is_daemon:
		Init.demonize()

	# Writing pid to file
	Init.write_pid(args.pid)

	reload_proc = Reloader.ReloaderTread(int(config.get("filters_reload", 600)), flts)
	try:
		reload_proc.start()
	except(thread.error):
		print("Spawned threads : %s. Can not spawn other one" % threading.active_count())

	while 1:
		conn, addr = socket.accept()
		proc = Worker.WorkerTread(conn, flts, default_answer, sql_pool)
		try:
			proc.start()
		except(thread.error):
			print("Spawned threads : %s. Can not spawn other one" % threading.active_count())


if __name__ == "__main__":
	main()
